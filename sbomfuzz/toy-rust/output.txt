16:18:19 [INFO] Logger setup complete.
16:18:23 [INFO] Database loaded: 4.28s, 489mb
16:18:23 [INFO] Analyzing local root: AbsPathBuf("c:\\Users\\wowkn\\Desktop\\repos\\SBOMFuzz-IDE\\sbomfuzz\\toy-rust")
16:18:23 [INFO] Number of project files in the workspace: 1
16:18:23 [INFO] manifest_or_root: c:\Users\wowkn\Desktop\repos\SBOMFuzz-IDE\sbomfuzz\toy-rust\Cargo.toml
16:18:23 [INFO] workspace_root: c:\Users\wowkn\Desktop\repos\SBOMFuzz-IDE\sbomfuzz\toy-rust
16:18:23 [INFO] n_packages: 35
16:18:23 [INFO] workspace: Cargo { root: Some("toy-rust"), n_packages: 8, n_sysroot_crates: 27, n_rustc_compiler_crates: 0, n_rustc_cfg: 36, n_cfg_overrides: 0, n_extra_includes: 0, toolchain: Some(Version { major: 1, minor: 87, patch: 0 }), data_layout: Ok("e-m:w-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-f80:128-n8:16:32:64-S128"), set_test: false, build_scripts: "ok" }
16:18:23 [INFO] Dependency Crate: "rand_xorshift-0.4.0"
16:18:23 [INFO] Dependency Crate: "cfg_if-1.0.1"
16:18:23 [INFO] Dependency Crate: "rand-0.8.5"
16:18:23 [INFO] Dependency Crate: "cfg_if-1.0.0"
16:18:23 [INFO] Dependency Crate: "panic_unwind-0.0.0"
16:18:23 [INFO] Dependency Crate: "rand-0.9.0"
16:18:23 [INFO] Dependency Crate: "compiler_builtins-0.1.152"
16:18:23 [INFO] Dependency Crate: "rand_core-0.6.4"
16:18:23 [INFO] Dependency Crate: "getopts-0.2.21"
16:18:23 [INFO] Dependency Crate: "allocator_api2-0.2.21"
16:18:23 [INFO] Dependency Crate: "unwind-0.0.0"
16:18:23 [INFO] Dependency Crate: "rustc_demangle-0.1.24"
16:18:23 [INFO] Dependency Crate: "ppv_lite86-0.2.21"
16:18:23 [INFO] Dependency Crate: "unicode_width-0.1.14"
16:18:23 [INFO] Dependency Crate: "panic_abort-0.0.0"
16:18:23 [INFO] Dependency Crate: "windows_targets-0.0.0"
16:18:23 [INFO] Dependency Crate: "rand_chacha-0.3.1"
16:18:23 [INFO] Dependency Crate: "zerocopy-0.8.17"
16:18:23 [INFO] Dependency Crate: "std_detect-0.1.5"
16:18:23 [INFO] Dependency Crate: "hashbrown-0.15.2"
16:18:23 [INFO] Dependency Crate: "getrandom-0.2.16"
16:18:23 [INFO] Dependency Crate: "rand_core-0.9.0"
16:18:23 [INFO] Dependency Crate: "zerocopy-0.8.26"
16:18:23 [INFO] Package: toy-rust (is_member: true)
16:18:23 [INFO] Running local analysis for 1 roots
16:18:23 [INFO] Source Root SourceRootId(21) contains 2 files
16:18:23 [INFO] Total number of files in the database: 2
16:18:23 [INFO] Analyzing file: AbsPathBuf("c:\\Users\\wowkn\\Desktop\\repos\\SBOMFuzz-IDE\\sbomfuzz\\toy-rust\\src\\main.rs")
16:18:23 [INFO] Module found: Some(Module { id: ModuleId { krate: Crate(Id(3c1c)), block: None, local_id: Idx::<ModuleData>(0) } })
16:18:23 [INFO] Use statement: use rand::Rng;
16:18:23 [INFO] Found def function: main
16:18:23 [INFO] Found function: main, fn token: fn
16:18:23 [INFO] 
 ---------
16:18:23 [INFO] FUNCTION: "fn main() {\r\n    println!(\"Hello, world!\");\r\n    let a = 10;\r\n    let b = 5;\r\n    let sum = add(a, b);\r\n    let difference = subtract(a, b);\r\n    let product = multiply(a, b);\r\n    let quotient = divide(a, b);\r\n    println!(\"Sum: {}\", sum);\r\n    println!(\"Difference: {}\", difference);\r\n    println!(\"Product: {}\", product);\r\n    println!(\"Quotient: {}\", quotient);\r\n}"
16:18:23 [INFO] Function belongs to crate: toy_rust
16:18:23 [INFO] Macro calls found: 5
16:18:23 [INFO] macro call resolved: "println!(\"Hello, world!\")"
16:18:23 [INFO] macro crate name: "std"
16:18:23 [INFO] macro call resolved: "println!(\"Sum: {}\", sum)"
16:18:23 [INFO] macro crate name: "std"
16:18:23 [INFO] macro call resolved: "println!(\"Difference: {}\", difference)"
16:18:23 [INFO] macro crate name: "std"
16:18:23 [INFO] macro call resolved: "println!(\"Product: {}\", product)"
16:18:23 [INFO] macro crate name: "std"
16:18:23 [INFO] macro call resolved: "println!(\"Quotient: {}\", quotient)"
16:18:23 [INFO] macro crate name: "std"
16:18:23 [INFO] Extracted path: "add"
16:18:23 [INFO] callable test call: "add(a, b)"
16:18:23 [INFO] callable call.expr(): "add"
16:18:25 [INFO] callable call.expr() type: "fn add(i32, i32) -> i32"
16:18:25 [INFO] callable &ast::Expr::cast: "add(a, b)"
16:18:25 [INFO] callable &ast::Expr::cast type: "i32"
16:18:25 [INFO] üß≠ Resolving function call: "add(a, b)"
16:18:25 [INFO] ‚ùå No callable function found for this expr: add(a, b)
16:18:25 [INFO] This is a callee: "add"
16:18:25 [INFO] ‚ùå No method resolution or assoc resolutions for this expr_id.
16:18:25 [INFO] This is a function call from sema: Name { symbol: "add", ctx: () }
16:18:25 [INFO] last resort from sema resolved to callable: Callable { ty: Type { env: TraitEnvironment { krate: Crate(Id(3c1c)), block: None, traits_from_clauses: [], env: Env([]) }, ty: FnDefId(Id(168bb))<[]> }, sig: CallableSig { params_and_return: [Int(I32), Int(I32), Int(I32)], is_varargs: false, safety: Safe, abi: Rust }, callee: Def(FunctionId(FunctionId(168bb))), is_bound_method: false }
16:18:25 [INFO] Analyzing function call chain for: Name { symbol: "add", ctx: () }
16:18:25 [INFO] Analyzing function call chain at depth: 0, function name: Name { symbol: "add", ctx: () }, function in crate: Some(CrateDisplayName { crate_name: CrateName("toy_rust"), canonical_name: "toy-rust" }), caller crate: toy_rust
16:18:25 [INFO] Found 0 expanded use statements
16:18:25 [INFO] syntax node: "/// Some test doc comments.\r\n/// To test jumping to function definition.\r\nfn add(a: i32, b: i32) -> i32 {\r\n    a + b\r\n}"
16:18:25 [INFO] No macro found
16:18:25 [INFO] Start analyzing function named : Name { symbol: "add", ctx: () }
16:18:25 [INFO] Storing function in cache: Name { symbol: "add", ctx: () }
16:18:25 [INFO] Storing function: Name { symbol: "add", ctx: () }
16:18:25 [INFO] function: Name { symbol: "add", ctx: () }
16:18:25 [INFO] parent param type: "i32"
16:18:25 [INFO] parent param type: "i32"
16:18:25 [INFO] Is entry node: false, caller_crate: Some(Crate { id: Crate(Id(3c1c)) }),  current_crate: Crate { id: Crate(Id(3c1c)) }
16:18:25 [INFO] Extracted path: "subtract"
16:18:25 [INFO] callable test call: "subtract(a, b)"
16:18:25 [INFO] callable call.expr(): "subtract"
16:18:25 [INFO] callable call.expr() type: "fn subtract(i32, i32) -> i32"
16:18:25 [INFO] callable &ast::Expr::cast: "subtract(a, b)"
16:18:25 [INFO] callable &ast::Expr::cast type: "i32"
16:18:25 [INFO] üß≠ Resolving function call: "subtract(a, b)"
16:18:25 [INFO] ‚ùå No callable function found for this expr: subtract(a, b)
16:18:25 [INFO] This is a callee: "subtract"
16:18:25 [INFO] ‚ùå No method resolution or assoc resolutions for this expr_id.
16:18:25 [INFO] This is a function call from sema: Name { symbol: "subtract", ctx: () }
16:18:25 [INFO] last resort from sema resolved to callable: Callable { ty: Type { env: TraitEnvironment { krate: Crate(Id(3c1c)), block: None, traits_from_clauses: [], env: Env([]) }, ty: FnDefId(Id(168bd))<[]> }, sig: CallableSig { params_and_return: [Int(I32), Int(I32), Int(I32)], is_varargs: false, safety: Safe, abi: Rust }, callee: Def(FunctionId(FunctionId(168bd))), is_bound_method: false }
16:18:25 [INFO] Analyzing function call chain for: Name { symbol: "subtract", ctx: () }
16:18:25 [INFO] Analyzing function call chain at depth: 0, function name: Name { symbol: "subtract", ctx: () }, function in crate: Some(CrateDisplayName { crate_name: CrateName("toy_rust"), canonical_name: "toy-rust" }), caller crate: toy_rust
16:18:25 [INFO] Found 0 expanded use statements
16:18:25 [INFO] syntax node: "fn subtract(a: i32, b: i32) -> i32 {\r\n    a - b\r\n}"
16:18:25 [INFO] No macro found
16:18:25 [INFO] Start analyzing function named : Name { symbol: "subtract", ctx: () }
16:18:25 [INFO] Storing function in cache: Name { symbol: "subtract", ctx: () }
16:18:25 [INFO] Storing function: Name { symbol: "subtract", ctx: () }
16:18:25 [INFO] function: Name { symbol: "subtract", ctx: () }
16:18:25 [INFO] parent param type: "i32"
16:18:25 [INFO] parent param type: "i32"
16:18:25 [INFO] Is entry node: false, caller_crate: Some(Crate { id: Crate(Id(3c1c)) }),  current_crate: Crate { id: Crate(Id(3c1c)) }
16:18:25 [INFO] Extracted path: "multiply"
16:18:25 [INFO] callable test call: "multiply(a, b)"
16:18:25 [INFO] callable call.expr(): "multiply"
16:18:25 [INFO] callable call.expr() type: "fn multiply(i32, i32) -> i32"
16:18:25 [INFO] callable &ast::Expr::cast: "multiply(a, b)"
16:18:25 [INFO] callable &ast::Expr::cast type: "i32"
16:18:25 [INFO] üß≠ Resolving function call: "multiply(a, b)"
16:18:25 [INFO] ‚ùå No callable function found for this expr: multiply(a, b)
16:18:25 [INFO] This is a callee: "multiply"
16:18:25 [INFO] ‚ùå No method resolution or assoc resolutions for this expr_id.
16:18:25 [INFO] This is a function call from sema: Name { symbol: "multiply", ctx: () }
16:18:25 [INFO] last resort from sema resolved to callable: Callable { ty: Type { env: TraitEnvironment { krate: Crate(Id(3c1c)), block: None, traits_from_clauses: [], env: Env([]) }, ty: FnDefId(Id(168be))<[]> }, sig: CallableSig { params_and_return: [Int(I32), Int(I32), Int(I32)], is_varargs: false, safety: Safe, abi: Rust }, callee: Def(FunctionId(FunctionId(168be))), is_bound_method: false }
16:18:25 [INFO] Analyzing function call chain for: Name { symbol: "multiply", ctx: () }
16:18:25 [INFO] Analyzing function call chain at depth: 0, function name: Name { symbol: "multiply", ctx: () }, function in crate: Some(CrateDisplayName { crate_name: CrateName("toy_rust"), canonical_name: "toy-rust" }), caller crate: toy_rust
16:18:25 [INFO] Found 0 expanded use statements
16:18:25 [INFO] syntax node: "fn multiply(a: i32, b: i32) -> i32 {\r\n    a * b\r\n}"
16:18:25 [INFO] No macro found
16:18:25 [INFO] Start analyzing function named : Name { symbol: "multiply", ctx: () }
16:18:25 [INFO] Storing function in cache: Name { symbol: "multiply", ctx: () }
16:18:25 [INFO] Storing function: Name { symbol: "multiply", ctx: () }
16:18:25 [INFO] function: Name { symbol: "multiply", ctx: () }
16:18:25 [INFO] parent param type: "i32"
16:18:25 [INFO] parent param type: "i32"
16:18:25 [INFO] Is entry node: false, caller_crate: Some(Crate { id: Crate(Id(3c1c)) }),  current_crate: Crate { id: Crate(Id(3c1c)) }
16:18:25 [INFO] Extracted path: "divide"
16:18:25 [INFO] callable test call: "divide(a, b)"
16:18:25 [INFO] callable call.expr(): "divide"
16:18:25 [INFO] callable call.expr() type: "fn divide(i32, i32) -> i32"
16:18:25 [INFO] callable &ast::Expr::cast: "divide(a, b)"
16:18:25 [INFO] callable &ast::Expr::cast type: "i32"
16:18:25 [INFO] üß≠ Resolving function call: "divide(a, b)"
16:18:25 [INFO] ‚ùå No callable function found for this expr: divide(a, b)
16:18:25 [INFO] This is a callee: "divide"
16:18:25 [INFO] ‚ùå No method resolution or assoc resolutions for this expr_id.
16:18:25 [INFO] This is a function call from sema: Name { symbol: "divide", ctx: () }
16:18:25 [INFO] last resort from sema resolved to callable: Callable { ty: Type { env: TraitEnvironment { krate: Crate(Id(3c1c)), block: None, traits_from_clauses: [], env: Env([]) }, ty: FnDefId(Id(168bf))<[]> }, sig: CallableSig { params_and_return: [Int(I32), Int(I32), Int(I32)], is_varargs: false, safety: Safe, abi: Rust }, callee: Def(FunctionId(FunctionId(168bf))), is_bound_method: false }
16:18:25 [INFO] Analyzing function call chain for: Name { symbol: "divide", ctx: () }
16:18:25 [INFO] Analyzing function call chain at depth: 0, function name: Name { symbol: "divide", ctx: () }, function in crate: Some(CrateDisplayName { crate_name: CrateName("toy_rust"), canonical_name: "toy-rust" }), caller crate: toy_rust
16:18:25 [INFO] Found 0 expanded use statements
16:18:25 [INFO] syntax node: "fn divide(a: i32, b: i32) -> i32 {\r\n    if b == 0 {\r\n        panic!(\"Cannot divide by zero\");\r\n    }\r\n    a / b\r\n}"
16:18:25 [INFO] Macro calls found: 1
16:18:25 [INFO] macro call resolved: "panic!(\"Cannot divide by zero\")"
16:18:25 [INFO] macro crate name: "std"
16:18:25 [INFO] Start analyzing function named : Name { symbol: "divide", ctx: () }
16:18:25 [INFO] Storing function in cache: Name { symbol: "divide", ctx: () }
16:18:25 [INFO] Storing function: Name { symbol: "divide", ctx: () }
16:18:25 [INFO] function: Name { symbol: "divide", ctx: () }
16:18:25 [INFO] parent param type: "i32"
16:18:25 [INFO] parent param type: "i32"
16:18:25 [INFO] Is entry node: false, caller_crate: Some(Crate { id: Crate(Id(3c1c)) }),  current_crate: Crate { id: Crate(Id(3c1c)) }
16:18:25 [INFO] Found def function: add
16:18:25 [INFO] Found function: add, fn token: fn
16:18:25 [INFO] 
 ---------
16:18:25 [INFO] FUNCTION: "/// Some test doc comments.\r\n/// To test jumping to function definition.\r\nfn add(a: i32, b: i32) -> i32 {\r\n    a + b\r\n}"
16:18:25 [INFO] Function belongs to crate: toy_rust
16:18:25 [INFO] No macro found
16:18:25 [INFO] Found def function: add_random
16:18:25 [INFO] Found function: add_random, fn token: fn
16:18:25 [INFO] 
 ---------
16:18:25 [INFO] FUNCTION: "fn add_random(a: i32) -> i32 {\r\n    let mut rng = rand::thread_rng();\r\n    let random_number: i32 = rng.gen_range(1..=10);\r\n    a + random_number\r\n}"
16:18:25 [INFO] Function belongs to crate: toy_rust
16:18:25 [INFO] No macro found
16:18:25 [INFO] Extracted path: "rand::thread_rng"
16:18:25 [INFO] callable test call: "rand::thread_rng()"
16:18:25 [INFO] callable call.expr(): "rand::thread_rng"
16:18:25 [INFO] callable call.expr() type: "fn thread_rng() -> ThreadRng"
16:18:25 [INFO] callable &ast::Expr::cast: "rand::thread_rng()"
16:18:25 [INFO] callable &ast::Expr::cast type: "ThreadRng"
16:18:25 [INFO] üß≠ Resolving function call: "rand::thread_rng()"
16:18:25 [INFO] ‚ùå No callable function found for this expr: rand::thread_rng()
16:18:25 [INFO] This is a callee: "rand::thread_rng"
16:18:25 [INFO] ‚ùå No method resolution or assoc resolutions for this expr_id.
16:18:25 [INFO] This is a function call from sema: Name { symbol: "thread_rng", ctx: () }
16:18:25 [INFO] last resort from sema resolved to callable: Callable { ty: Type { env: TraitEnvironment { krate: Crate(Id(3c1c)), block: None, traits_from_clauses: [], env: Env([]) }, ty: FnDefId(Id(168a4))<[]> }, sig: CallableSig { params_and_return: [AdtId(StructId(StructId(148bf)))<[]>], is_varargs: false, safety: Safe, abi: Rust }, callee: Def(FunctionId(FunctionId(168a4))), is_bound_method: false }
16:18:25 [INFO] Analyzing function call chain for: Name { symbol: "thread_rng", ctx: () }
16:18:25 [INFO] Analyzing function call chain at depth: 0, function name: Name { symbol: "thread_rng", ctx: () }, function in crate: Some(CrateDisplayName { crate_name: CrateName("rand"), canonical_name: "rand" }), caller crate: toy_rust
16:18:25 [INFO] Found 0 expanded use statements
16:18:25 [INFO] syntax node: "/// Retrieve the lazily-initialized thread-local random number generator,\n/// seeded by the system. Intended to be used in method chaining style,\n/// e.g. `thread_rng().gen::<i32>()`, or cached locally, e.g.\n/// `let mut rng = thread_rng();`.  Invoked by the `Default` trait, making\n/// `ThreadRng::default()` equivalent.\n///\n/// For more information see [`ThreadRng`].\n#[cfg_attr(doc_cfg, doc(cfg(all(feature = \"std\", feature = \"std_rng\"))))]\npub fn thread_rng() -> ThreadRng {\n    let rng = THREAD_RNG_KEY.with(|t| t.clone());\n    ThreadRng { rng }\n}"
16:18:25 [INFO] No macro found
16:18:25 [INFO] Start analyzing function named : Name { symbol: "thread_rng", ctx: () }
16:18:25 [INFO] Storing function in cache: Name { symbol: "thread_rng", ctx: () }
16:18:25 [INFO] Storing function: Name { symbol: "thread_rng", ctx: () }
16:18:25 [INFO] function: Name { symbol: "thread_rng", ctx: () }
16:18:25 [INFO] Is entry node: true, caller_crate: Some(Crate { id: Crate(Id(3c1c)) }),  current_crate: Crate { id: Crate(Id(3c1b)) }
16:18:25 [INFO] Extracted path: "rng"
16:18:25 [INFO] callable test method call: "rng.gen_range(1..=10)"
16:18:25 [INFO] This is a function call: Name { symbol: "gen_range", ctx: () }
16:18:25 [INFO] Substitution[0]: ThreadRng
16:18:25 [INFO] Substitution[1]: i32
16:18:25 [INFO] Substitution[2]: RangeInclusive<i32>
16:18:25 [INFO] üîç Matched concrete type in substitution: i32
16:18:25 [INFO] Matched function: [], rand
16:18:25 [INFO] Analyzing function call chain for: Name { symbol: "gen_range", ctx: () }
16:18:25 [INFO] Analyzing function call chain at depth: 0, function name: Name { symbol: "gen_range", ctx: () }, function in crate: Some(CrateDisplayName { crate_name: CrateName("rand"), canonical_name: "rand" }), caller crate: toy_rust
16:18:25 [INFO] Found 0 expanded use statements
16:18:25 [INFO] syntax node: "/// Generate a random value in the given range.\n    ///\n    /// This function is optimised for the case that only a single sample is\n    /// made from the given range. See also the [`Uniform`] distribution\n    /// type which may be faster if sampling from the same range repeatedly.\n    ///\n    /// Only `gen_range(low..high)` and `gen_range(low..=high)` are supported.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the range is empty.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::{thread_rng, Rng};\n    ///\n    /// let mut rng = thread_rng();\n    ///\n    /// // Exclusive range\n    /// let n: u32 = rng.gen_range(0..10);\n    /// println!(\"{}\", n);\n    /// let m: f64 = rng.gen_range(-40.0..1.3e5);\n    /// println!(\"{}\", m);\n    ///\n    /// // Inclusive range\n    /// let n: u32 = rng.gen_range(0..=10);\n    /// println!(\"{}\", n);\n    /// ```\n    ///\n    /// [`Uniform`]: distributions::uniform::Uniform\n    fn gen_range<T, R>(&mut self, range: R) -> T\n    where\n        T: SampleUniform,\n        R: SampleRange<T>\n    {\n        assert!(!range.is_empty(), \"cannot sample empty range\");\n        range.sample_single(self)\n    }"
16:18:25 [INFO] Macro calls found: 1
16:18:25 [INFO] macro call resolved: "assert!(!range.is_empty(), \"cannot sample empty range\")"
16:18:25 [INFO] macro crate name: "core"
16:18:25 [INFO] Start analyzing function named : Name { symbol: "gen_range", ctx: () }
16:18:25 [INFO] Storing function in cache: Name { symbol: "gen_range", ctx: () }
16:18:25 [INFO] Storing function: Name { symbol: "gen_range", ctx: () }
16:18:25 [INFO] function: Name { symbol: "gen_range", ctx: () }
16:18:25 [INFO] parent param type: "&mut Self"
16:18:25 [INFO] Resolving type: "Self"
16:18:25 [INFO] as type param: Some(TypeParam { id: TypeParamId(TypeOrConstParamId { parent: TraitId(TraitId(5e15)), local_id: Idx::<TypeOrConstParamData>(0) }) })
16:18:25 [INFO] Walking type parameter: Self
16:18:25 [INFO] Trait bound: RngCore
16:18:25 [INFO] Resolved targets: [Trait(Trait { id: TraitId(5e04) }), Module(Module { id: ModuleId { krate: Crate(Id(3c19)), block: None, local_id: Idx::<ModuleData>(0) } })]
16:18:25 [INFO] Skipping unresolved target: Module(Module { id: ModuleId { krate: Crate(Id(3c19)), block: None, local_id: Idx::<ModuleData>(0) } })
16:18:25 [INFO] parent param type: "R"
16:18:25 [INFO] Resolving type: "R"
16:18:25 [INFO] as type param: Some(TypeParam { id: TypeParamId(TypeOrConstParamId { parent: FunctionId(FunctionId(2c282)), local_id: Idx::<TypeOrConstParamData>(1) }) })
16:18:25 [INFO] Pre-checking type parameter: R
16:18:25 [INFO] Trait bound: SampleRange
16:18:25 [INFO] Trait bound: Sized
16:18:25 [INFO] Trait bound: Sized
16:18:25 [INFO] Resolved targets: [Trait(Trait { id: TraitId(5e13) }), Module(Module { id: ModuleId { krate: Crate(Id(3c1b)), block: None, local_id: Idx::<ModuleData>(11) } }), Trait(Trait { id: TraitId(5d15) })]
16:18:25 [INFO] Skipping unresolved target: Module(Module { id: ModuleId { krate: Crate(Id(3c1b)), block: None, local_id: Idx::<ModuleData>(11) } })
16:18:25 [INFO] Is entry node: true, caller_crate: Some(Crate { id: Crate(Id(3c1c)) }),  current_crate: Crate { id: Crate(Id(3c1b)) }
16:18:25 [INFO] Found def function: subtract
16:18:25 [INFO] Found function: subtract, fn token: fn
16:18:25 [INFO] 
 ---------
16:18:25 [INFO] FUNCTION: "fn subtract(a: i32, b: i32) -> i32 {\r\n    a - b\r\n}"
16:18:25 [INFO] Function belongs to crate: toy_rust
16:18:25 [INFO] No macro found
16:18:25 [INFO] Found def function: multiply
16:18:25 [INFO] Found function: multiply, fn token: fn
16:18:25 [INFO] 
 ---------
16:18:25 [INFO] FUNCTION: "fn multiply(a: i32, b: i32) -> i32 {\r\n    a * b\r\n}"
16:18:25 [INFO] Function belongs to crate: toy_rust
16:18:25 [INFO] No macro found
16:18:25 [INFO] Found def function: divide
16:18:25 [INFO] Found function: divide, fn token: fn
16:18:25 [INFO] 
 ---------
16:18:25 [INFO] FUNCTION: "fn divide(a: i32, b: i32) -> i32 {\r\n    if b == 0 {\r\n        panic!(\"Cannot divide by zero\");\r\n    }\r\n    a / b\r\n}"
16:18:25 [INFO] Function belongs to crate: toy_rust
16:18:25 [INFO] Macro calls found: 1
16:18:25 [INFO] macro call resolved: "panic!(\"Cannot divide by zero\")"
16:18:25 [INFO] macro crate name: "std"
16:18:25 [INFO] 
 ----------- done with file ----------- 

16:18:26 [INFO] number of resolved external functions / Number of external functions: 18644 / 52041
16:18:26 [INFO] number of resolved internal functions / Number of internal functions: 6 / 6
16:18:26 [INFO] name: "0.1.0"
16:18:26 [INFO] name: "cfg_if"
16:18:26 [INFO] name: "getrandom"
16:18:26 [INFO] name: "libc"
16:18:26 [INFO] name: "ppv_lite86"
16:18:26 [INFO] name: "rand"
16:18:26 [INFO] name: "rand_chacha"
16:18:26 [INFO] name: "rand_core"
16:18:26 [INFO] name: "zerocopy"
16:18:26 [INFO] name: "0.1.0"
16:18:26 [INFO] name: "cfg_if"
16:18:26 [INFO] name: "getrandom"
16:18:26 [INFO] name: "libc"
16:18:26 [INFO] name: "ppv_lite86"
16:18:26 [INFO] name: "rand"
16:18:26 [INFO] name: "rand_chacha"
16:18:26 [INFO] name: "rand_core"
16:18:26 [INFO] name: "zerocopy"
16:18:26 [INFO] SBOM dep num 8
16:18:26 [INFO] crate_link, rand0.8.5: None :  "https://rust-random.github.io/book"
16:18:26 [INFO] crate_link, rand0.8.5: None :  "https://rust-random.github.io/book"
