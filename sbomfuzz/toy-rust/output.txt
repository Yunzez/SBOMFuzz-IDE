21:24:25 [INFO] Logger setup complete.
21:24:39 [INFO] Database loaded: 14.28s, 0b
21:24:39 [INFO] Analyzing local root: AbsPathBuf("/Users/yunzezhao/Code/SBOMFuzz-IDE/sbomfuzz/toy-rust")
21:24:39 [INFO] Number of project files in the workspace: 1
21:24:39 [INFO] manifest_or_root: /Users/yunzezhao/Code/SBOMFuzz-IDE/sbomfuzz/toy-rust/Cargo.toml
21:24:39 [INFO] workspace_root: /Users/yunzezhao/Code/SBOMFuzz-IDE/sbomfuzz/toy-rust
21:24:39 [INFO] n_packages: 35
21:24:39 [INFO] workspace: Cargo { root: Some("toy-rust"), n_packages: 9, n_sysroot_crates: 26, n_rustc_compiler_crates: 0, n_rustc_cfg: 85, n_cfg_overrides: 0, n_extra_includes: 0, toolchain: Some(Version { major: 1, minor: 89, patch: 0, pre: Prerelease("nightly") }), data_layout: Ok("e-m:o-p270:32:32-p271:32:32-p272:64:64-i64:64-i128:128-n32:64-S128-Fn32"), set_test: false, build_scripts: "ok" }
21:24:39 [INFO] Dependency Crate: "unicode_width-0.2.1"
21:24:39 [INFO] Dependency Crate: "ppv_lite86-0.2.21"
21:24:39 [INFO] Dependency Crate: "cfg_if-1.0.1"
21:24:39 [INFO] Dependency Crate: "compiler_builtins-0.1.160"
21:24:39 [INFO] Dependency Crate: "panic_abort-0.0.0"
21:24:39 [INFO] Dependency Crate: "rand_xorshift-0.4.0"
21:24:39 [INFO] Dependency Crate: "rand_chacha-0.3.1"
21:24:39 [INFO] Dependency Crate: "unwind-0.0.0"
21:24:39 [INFO] Dependency Crate: "rustc_demangle-0.1.25"
21:24:39 [INFO] Dependency Crate: "getopts-0.2.23"
21:24:39 [INFO] Dependency Crate: "getrandom-0.2.16"
21:24:39 [INFO] Dependency Crate: "rand_core-0.9.3"
21:24:39 [INFO] Dependency Crate: "libc-0.2.172"
21:24:39 [INFO] Dependency Crate: "panic_unwind-0.0.0"
21:24:39 [INFO] Dependency Crate: "zerocopy-0.8.26"
21:24:39 [INFO] Dependency Crate: "std_detect-0.1.5"
21:24:39 [INFO] Dependency Crate: "hashbrown-0.15.4"
21:24:39 [INFO] Dependency Crate: "rand_core-0.6.4"
21:24:39 [INFO] Dependency Crate: "rustc_literal_escaper-0.0.2"
21:24:39 [INFO] Dependency Crate: "rand-0.8.5"
21:24:39 [INFO] Dependency Crate: "cfg_if-1.0.1"
21:24:39 [INFO] Dependency Crate: "libc-0.2.174"
21:24:39 [INFO] Dependency Crate: "rand-0.9.1"
21:24:39 [INFO] Package: toy-rust (is_member: true)
21:24:39 [INFO] Running local analysis for 1 roots
21:24:39 [INFO] Source Root SourceRootId(20) contains 2 files
21:24:39 [INFO] Total number of files in the database: 2
21:24:39 [INFO] Analyzing file: AbsPathBuf("/Users/yunzezhao/Code/SBOMFuzz-IDE/sbomfuzz/toy-rust/src/main.rs")
21:24:39 [INFO] Module found: Some(Module { id: ModuleId { krate: Crate(Id(3c1c)), block: None, local_id: Idx::<ModuleData>(0) } })
21:24:39 [INFO] Use statement: use rand::Rng;
21:24:39 [INFO] Found def function: main
21:24:39 [INFO] Found function: main, fn token: fn
21:24:39 [INFO] 
 ---------
21:24:39 [INFO] FUNCTION: "fn main() {\n    println!(\"Hello, world!\");\n    let a = 10;\n    let b = 5;\n    let sum = add(a, b);\n    let difference = subtract(a, b);\n    let product = multiply(a, b);\n    let quotient = divide(a, b);\n    println!(\"Sum: {}\", sum);\n    println!(\"Difference: {}\", difference);\n    println!(\"Product: {}\", product);\n    println!(\"Quotient: {}\", quotient);\n}"
21:24:39 [INFO] Function belongs to crate: toy_rust
21:24:39 [INFO] Macro calls found: 5
21:24:39 [INFO] macro call resolved: "println!(\"Hello, world!\")"
21:24:39 [INFO] macro crate name: "std"
21:24:39 [INFO] macro call resolved: "println!(\"Sum: {}\", sum)"
21:24:39 [INFO] macro crate name: "std"
21:24:39 [INFO] macro call resolved: "println!(\"Difference: {}\", difference)"
21:24:39 [INFO] macro crate name: "std"
21:24:39 [INFO] macro call resolved: "println!(\"Product: {}\", product)"
21:24:39 [INFO] macro crate name: "std"
21:24:39 [INFO] macro call resolved: "println!(\"Quotient: {}\", quotient)"
21:24:39 [INFO] macro crate name: "std"
21:24:39 [INFO] Extracted path: "add"
21:24:39 [INFO] callable test call: "add(a, b)"
21:24:39 [INFO] callable call.expr(): "add"
21:24:46 [INFO] callable call.expr() type: "fn add(i32, i32) -> i32"
21:24:46 [INFO] callable &ast::Expr::cast: "add(a, b)"
21:24:46 [INFO] callable &ast::Expr::cast type: "i32"
21:24:46 [INFO] üß≠ Resolving function call: "add(a, b)"
21:24:46 [INFO] ‚ùå No callable function found for this expr: add(a, b)
21:24:46 [INFO] This is a callee: "add"
21:24:46 [INFO] ‚ùå No method resolution or assoc resolutions for this expr_id.
21:24:46 [INFO] This is a function call from sema: Name { symbol: "add", ctx: () }
21:24:46 [INFO] last resort from sema resolved to callable: Callable { ty: Type { env: TraitEnvironment { krate: Crate(Id(3c1c)), block: None, traits_from_clauses: [], env: Env([]) }, ty: FnDefId(Id(16134))<[]> }, sig: CallableSig { params_and_return: [Int(I32), Int(I32), Int(I32)], is_varargs: false, safety: Safe, abi: Rust }, callee: Def(FunctionId(FunctionId(16134))), is_bound_method: false }
21:24:46 [INFO] Analyzing function call chain for: Name { symbol: "add", ctx: () }
21:24:46 [INFO] Analyzing function call chain at depth: 0, function name: Name { symbol: "add", ctx: () }, function in crate: Some(CrateDisplayName { crate_name: CrateName("toy_rust"), canonical_name: "toy-rust" }), caller crate: toy_rust
21:24:46 [INFO] Found 0 expanded use statements
21:24:46 [INFO] syntax node: "fn add(a: i32, b: i32) -> i32 {\n    a + b\n}"
21:24:46 [INFO] No macro found
21:24:46 [INFO] Start analyzing function named : Name { symbol: "add", ctx: () }
21:24:46 [INFO] Storing function in cache: Name { symbol: "add", ctx: () }
21:24:46 [INFO] Storing function: Name { symbol: "add", ctx: () }
21:24:46 [INFO] function: Name { symbol: "add", ctx: () }
21:24:46 [INFO] parent param type: "i32"
21:24:46 [INFO] parent param type: "i32"
21:24:46 [INFO] Is entry node: false, caller_crate: Some(Crate { id: Crate(Id(3c1c)) }),  current_crate: Crate { id: Crate(Id(3c1c)) }
21:24:46 [INFO] Extracted path: "subtract"
21:24:46 [INFO] callable test call: "subtract(a, b)"
21:24:46 [INFO] callable call.expr(): "subtract"
21:24:46 [INFO] callable call.expr() type: "fn subtract(i32, i32) -> i32"
21:24:46 [INFO] callable &ast::Expr::cast: "subtract(a, b)"
21:24:46 [INFO] callable &ast::Expr::cast type: "i32"
21:24:46 [INFO] üß≠ Resolving function call: "subtract(a, b)"
21:24:46 [INFO] ‚ùå No callable function found for this expr: subtract(a, b)
21:24:46 [INFO] This is a callee: "subtract"
21:24:46 [INFO] ‚ùå No method resolution or assoc resolutions for this expr_id.
21:24:46 [INFO] This is a function call from sema: Name { symbol: "subtract", ctx: () }
21:24:46 [INFO] last resort from sema resolved to callable: Callable { ty: Type { env: TraitEnvironment { krate: Crate(Id(3c1c)), block: None, traits_from_clauses: [], env: Env([]) }, ty: FnDefId(Id(16136))<[]> }, sig: CallableSig { params_and_return: [Int(I32), Int(I32), Int(I32)], is_varargs: false, safety: Safe, abi: Rust }, callee: Def(FunctionId(FunctionId(16136))), is_bound_method: false }
21:24:46 [INFO] Analyzing function call chain for: Name { symbol: "subtract", ctx: () }
21:24:46 [INFO] Analyzing function call chain at depth: 0, function name: Name { symbol: "subtract", ctx: () }, function in crate: Some(CrateDisplayName { crate_name: CrateName("toy_rust"), canonical_name: "toy-rust" }), caller crate: toy_rust
21:24:46 [INFO] Found 0 expanded use statements
21:24:46 [INFO] syntax node: "fn subtract(a: i32, b: i32) -> i32 {\n    a - b\n}"
21:24:46 [INFO] No macro found
21:24:46 [INFO] Start analyzing function named : Name { symbol: "subtract", ctx: () }
21:24:46 [INFO] Storing function in cache: Name { symbol: "subtract", ctx: () }
21:24:46 [INFO] Storing function: Name { symbol: "subtract", ctx: () }
21:24:46 [INFO] function: Name { symbol: "subtract", ctx: () }
21:24:46 [INFO] parent param type: "i32"
21:24:46 [INFO] parent param type: "i32"
21:24:46 [INFO] Is entry node: false, caller_crate: Some(Crate { id: Crate(Id(3c1c)) }),  current_crate: Crate { id: Crate(Id(3c1c)) }
21:24:46 [INFO] Extracted path: "multiply"
21:24:46 [INFO] callable test call: "multiply(a, b)"
21:24:46 [INFO] callable call.expr(): "multiply"
21:24:46 [INFO] callable call.expr() type: "fn multiply(i32, i32) -> i32"
21:24:46 [INFO] callable &ast::Expr::cast: "multiply(a, b)"
21:24:46 [INFO] callable &ast::Expr::cast type: "i32"
21:24:46 [INFO] üß≠ Resolving function call: "multiply(a, b)"
21:24:46 [INFO] ‚ùå No callable function found for this expr: multiply(a, b)
21:24:46 [INFO] This is a callee: "multiply"
21:24:46 [INFO] ‚ùå No method resolution or assoc resolutions for this expr_id.
21:24:46 [INFO] This is a function call from sema: Name { symbol: "multiply", ctx: () }
21:24:46 [INFO] last resort from sema resolved to callable: Callable { ty: Type { env: TraitEnvironment { krate: Crate(Id(3c1c)), block: None, traits_from_clauses: [], env: Env([]) }, ty: FnDefId(Id(16137))<[]> }, sig: CallableSig { params_and_return: [Int(I32), Int(I32), Int(I32)], is_varargs: false, safety: Safe, abi: Rust }, callee: Def(FunctionId(FunctionId(16137))), is_bound_method: false }
21:24:46 [INFO] Analyzing function call chain for: Name { symbol: "multiply", ctx: () }
21:24:46 [INFO] Analyzing function call chain at depth: 0, function name: Name { symbol: "multiply", ctx: () }, function in crate: Some(CrateDisplayName { crate_name: CrateName("toy_rust"), canonical_name: "toy-rust" }), caller crate: toy_rust
21:24:46 [INFO] Found 0 expanded use statements
21:24:46 [INFO] syntax node: "fn multiply(a: i32, b: i32) -> i32 {\n    a * b\n}"
21:24:46 [INFO] No macro found
21:24:46 [INFO] Start analyzing function named : Name { symbol: "multiply", ctx: () }
21:24:46 [INFO] Storing function in cache: Name { symbol: "multiply", ctx: () }
21:24:46 [INFO] Storing function: Name { symbol: "multiply", ctx: () }
21:24:46 [INFO] function: Name { symbol: "multiply", ctx: () }
21:24:46 [INFO] parent param type: "i32"
21:24:46 [INFO] parent param type: "i32"
21:24:46 [INFO] Is entry node: false, caller_crate: Some(Crate { id: Crate(Id(3c1c)) }),  current_crate: Crate { id: Crate(Id(3c1c)) }
21:24:46 [INFO] Extracted path: "divide"
21:24:46 [INFO] callable test call: "divide(a, b)"
21:24:46 [INFO] callable call.expr(): "divide"
21:24:46 [INFO] callable call.expr() type: "fn divide(i32, i32) -> i32"
21:24:46 [INFO] callable &ast::Expr::cast: "divide(a, b)"
21:24:46 [INFO] callable &ast::Expr::cast type: "i32"
21:24:46 [INFO] üß≠ Resolving function call: "divide(a, b)"
21:24:46 [INFO] ‚ùå No callable function found for this expr: divide(a, b)
21:24:46 [INFO] This is a callee: "divide"
21:24:46 [INFO] ‚ùå No method resolution or assoc resolutions for this expr_id.
21:24:46 [INFO] This is a function call from sema: Name { symbol: "divide", ctx: () }
21:24:46 [INFO] last resort from sema resolved to callable: Callable { ty: Type { env: TraitEnvironment { krate: Crate(Id(3c1c)), block: None, traits_from_clauses: [], env: Env([]) }, ty: FnDefId(Id(16138))<[]> }, sig: CallableSig { params_and_return: [Int(I32), Int(I32), Int(I32)], is_varargs: false, safety: Safe, abi: Rust }, callee: Def(FunctionId(FunctionId(16138))), is_bound_method: false }
21:24:46 [INFO] Analyzing function call chain for: Name { symbol: "divide", ctx: () }
21:24:46 [INFO] Analyzing function call chain at depth: 0, function name: Name { symbol: "divide", ctx: () }, function in crate: Some(CrateDisplayName { crate_name: CrateName("toy_rust"), canonical_name: "toy-rust" }), caller crate: toy_rust
21:24:46 [INFO] Found 0 expanded use statements
21:24:46 [INFO] syntax node: "fn divide(a: i32, b: i32) -> i32 {\n    if b == 0 {\n        panic!(\"Cannot divide by zero\");\n    }\n    a / b\n}"
21:24:46 [INFO] Macro calls found: 1
21:24:46 [INFO] macro call resolved: "panic!(\"Cannot divide by zero\")"
21:24:46 [INFO] macro crate name: "std"
21:24:46 [INFO] Start analyzing function named : Name { symbol: "divide", ctx: () }
21:24:46 [INFO] Storing function in cache: Name { symbol: "divide", ctx: () }
21:24:46 [INFO] Storing function: Name { symbol: "divide", ctx: () }
21:24:46 [INFO] function: Name { symbol: "divide", ctx: () }
21:24:46 [INFO] parent param type: "i32"
21:24:46 [INFO] parent param type: "i32"
21:24:46 [INFO] Is entry node: false, caller_crate: Some(Crate { id: Crate(Id(3c1c)) }),  current_crate: Crate { id: Crate(Id(3c1c)) }
21:24:46 [INFO] Found def function: add
21:24:46 [INFO] Found function: add, fn token: fn
21:24:46 [INFO] 
 ---------
21:24:46 [INFO] FUNCTION: "fn add(a: i32, b: i32) -> i32 {\n    a + b\n}"
21:24:46 [INFO] Function belongs to crate: toy_rust
21:24:46 [INFO] No macro found
21:24:46 [INFO] Found def function: add_random
21:24:46 [INFO] Found function: add_random, fn token: fn
21:24:46 [INFO] 
 ---------
21:24:46 [INFO] FUNCTION: "fn add_random(a: i32) -> i32 {\n    let mut rng = rand::thread_rng();\n    let random_number: i32 = rng.gen_range(1..=10);\n    a + random_number\n}"
21:24:46 [INFO] Function belongs to crate: toy_rust
21:24:46 [INFO] No macro found
21:24:46 [INFO] Extracted path: "rand::thread_rng"
21:24:46 [INFO] callable test call: "rand::thread_rng()"
21:24:46 [INFO] callable call.expr(): "rand::thread_rng"
21:24:46 [INFO] callable call.expr() type: "fn thread_rng() -> ThreadRng"
21:24:46 [INFO] callable &ast::Expr::cast: "rand::thread_rng()"
21:24:46 [INFO] callable &ast::Expr::cast type: "ThreadRng"
21:24:46 [INFO] üß≠ Resolving function call: "rand::thread_rng()"
21:24:46 [INFO] ‚ùå No callable function found for this expr: rand::thread_rng()
21:24:46 [INFO] This is a callee: "rand::thread_rng"
21:24:46 [INFO] ‚ùå No method resolution or assoc resolutions for this expr_id.
21:24:46 [INFO] This is a function call from sema: Name { symbol: "thread_rng", ctx: () }
21:24:46 [INFO] last resort from sema resolved to callable: Callable { ty: Type { env: TraitEnvironment { krate: Crate(Id(3c1c)), block: None, traits_from_clauses: [], env: Env([]) }, ty: FnDefId(Id(1609e))<[]> }, sig: CallableSig { params_and_return: [AdtId(StructId(StructId(13a03)))<[]>], is_varargs: false, safety: Safe, abi: Rust }, callee: Def(FunctionId(FunctionId(1609e))), is_bound_method: false }
21:24:46 [INFO] Analyzing function call chain for: Name { symbol: "thread_rng", ctx: () }
21:24:46 [INFO] Analyzing function call chain at depth: 0, function name: Name { symbol: "thread_rng", ctx: () }, function in crate: Some(CrateDisplayName { crate_name: CrateName("rand"), canonical_name: "rand" }), caller crate: toy_rust
21:24:46 [INFO] Found 0 expanded use statements
21:24:46 [INFO] syntax node: "/// Retrieve the lazily-initialized thread-local random number generator,\n/// seeded by the system. Intended to be used in method chaining style,\n/// e.g. `thread_rng().gen::<i32>()`, or cached locally, e.g.\n/// `let mut rng = thread_rng();`.  Invoked by the `Default` trait, making\n/// `ThreadRng::default()` equivalent.\n///\n/// For more information see [`ThreadRng`].\n#[cfg_attr(doc_cfg, doc(cfg(all(feature = \"std\", feature = \"std_rng\"))))]\npub fn thread_rng() -> ThreadRng {\n    let rng = THREAD_RNG_KEY.with(|t| t.clone());\n    ThreadRng { rng }\n}"
21:24:46 [INFO] No macro found
21:24:46 [INFO] Start analyzing function named : Name { symbol: "thread_rng", ctx: () }
21:24:46 [INFO] Storing function in cache: Name { symbol: "thread_rng", ctx: () }
21:24:46 [INFO] Storing function: Name { symbol: "thread_rng", ctx: () }
21:24:46 [INFO] function: Name { symbol: "thread_rng", ctx: () }
21:24:46 [INFO] Is entry node: true, caller_crate: Some(Crate { id: Crate(Id(3c1c)) }),  current_crate: Crate { id: Crate(Id(3c1b)) }
21:24:46 [INFO] Extracted path: "rng"
21:24:46 [INFO] callable test method call: "rng.gen_range(1..=10)"
21:24:46 [INFO] This is a function call: Name { symbol: "gen_range", ctx: () }
21:24:46 [INFO] Substitution[0]: ThreadRng
21:24:46 [INFO] Substitution[1]: i32
21:24:46 [INFO] Substitution[2]: RangeInclusive<i32>
21:24:46 [INFO] üîç Matched concrete type in substitution: i32
21:24:46 [INFO] Matched function: [], rand
21:24:46 [INFO] Analyzing function call chain for: Name { symbol: "gen_range", ctx: () }
21:24:46 [INFO] Analyzing function call chain at depth: 0, function name: Name { symbol: "gen_range", ctx: () }, function in crate: Some(CrateDisplayName { crate_name: CrateName("rand"), canonical_name: "rand" }), caller crate: toy_rust
21:24:46 [INFO] Found 0 expanded use statements
21:24:46 [INFO] syntax node: "/// Generate a random value in the given range.\n    ///\n    /// This function is optimised for the case that only a single sample is\n    /// made from the given range. See also the [`Uniform`] distribution\n    /// type which may be faster if sampling from the same range repeatedly.\n    ///\n    /// Only `gen_range(low..high)` and `gen_range(low..=high)` are supported.\n    ///\n    /// # Panics\n    ///\n    /// Panics if the range is empty.\n    ///\n    /// # Example\n    ///\n    /// ```\n    /// use rand::{thread_rng, Rng};\n    ///\n    /// let mut rng = thread_rng();\n    ///\n    /// // Exclusive range\n    /// let n: u32 = rng.gen_range(0..10);\n    /// println!(\"{}\", n);\n    /// let m: f64 = rng.gen_range(-40.0..1.3e5);\n    /// println!(\"{}\", m);\n    ///\n    /// // Inclusive range\n    /// let n: u32 = rng.gen_range(0..=10);\n    /// println!(\"{}\", n);\n    /// ```\n    ///\n    /// [`Uniform`]: distributions::uniform::Uniform\n    fn gen_range<T, R>(&mut self, range: R) -> T\n    where\n        T: SampleUniform,\n        R: SampleRange<T>\n    {\n        assert!(!range.is_empty(), \"cannot sample empty range\");\n        range.sample_single(self)\n    }"
21:24:46 [INFO] Macro calls found: 1
21:24:46 [INFO] macro call resolved: "assert!(!range.is_empty(), \"cannot sample empty range\")"
21:24:46 [INFO] macro crate name: "core"
21:24:46 [INFO] Start analyzing function named : Name { symbol: "gen_range", ctx: () }
21:24:46 [INFO] Storing function in cache: Name { symbol: "gen_range", ctx: () }
21:24:46 [INFO] Storing function: Name { symbol: "gen_range", ctx: () }
21:24:46 [INFO] function: Name { symbol: "gen_range", ctx: () }
21:24:46 [INFO] parent param type: "&mut Self"
21:24:46 [INFO] Resolving type: "Self"
21:24:46 [INFO] as type param: Some(TypeParam { id: TypeParamId(TypeOrConstParamId { parent: TraitId(TraitId(49f3)), local_id: Idx::<TypeOrConstParamData>(0) }) })
21:24:46 [INFO] Walking type parameter: Self
21:24:46 [INFO] Trait bound: RngCore
21:24:46 [INFO] Resolved targets: [Trait(Trait { id: TraitId(49e2) }), Module(Module { id: ModuleId { krate: Crate(Id(3c19)), block: None, local_id: Idx::<ModuleData>(0) } })]
21:24:46 [INFO] Skipping unresolved target: Module(Module { id: ModuleId { krate: Crate(Id(3c19)), block: None, local_id: Idx::<ModuleData>(0) } })
21:24:46 [INFO] parent param type: "R"
21:24:46 [INFO] Resolving type: "R"
21:24:46 [INFO] as type param: Some(TypeParam { id: TypeParamId(TypeOrConstParamId { parent: FunctionId(FunctionId(2d1f9)), local_id: Idx::<TypeOrConstParamData>(1) }) })
21:24:46 [INFO] Pre-checking type parameter: R
21:24:46 [INFO] Trait bound: SampleRange
21:24:46 [INFO] Trait bound: Sized
21:24:46 [INFO] Trait bound: Sized
21:24:46 [INFO] Resolved targets: [Trait(Trait { id: TraitId(49f1) }), Module(Module { id: ModuleId { krate: Crate(Id(3c1b)), block: None, local_id: Idx::<ModuleData>(11) } }), Trait(Trait { id: TraitId(4906) })]
21:24:46 [INFO] Skipping unresolved target: Module(Module { id: ModuleId { krate: Crate(Id(3c1b)), block: None, local_id: Idx::<ModuleData>(11) } })
21:24:46 [INFO] Is entry node: true, caller_crate: Some(Crate { id: Crate(Id(3c1c)) }),  current_crate: Crate { id: Crate(Id(3c1b)) }
21:24:46 [INFO] Found def function: subtract
21:24:46 [INFO] Found function: subtract, fn token: fn
21:24:46 [INFO] 
 ---------
21:24:46 [INFO] FUNCTION: "fn subtract(a: i32, b: i32) -> i32 {\n    a - b\n}"
21:24:46 [INFO] Function belongs to crate: toy_rust
21:24:46 [INFO] No macro found
21:24:46 [INFO] Found def function: multiply
21:24:46 [INFO] Found function: multiply, fn token: fn
21:24:46 [INFO] 
 ---------
21:24:46 [INFO] FUNCTION: "fn multiply(a: i32, b: i32) -> i32 {\n    a * b\n}"
21:24:46 [INFO] Function belongs to crate: toy_rust
21:24:46 [INFO] No macro found
21:24:46 [INFO] Found def function: divide
21:24:46 [INFO] Found function: divide, fn token: fn
21:24:46 [INFO] 
 ---------
21:24:46 [INFO] FUNCTION: "fn divide(a: i32, b: i32) -> i32 {\n    if b == 0 {\n        panic!(\"Cannot divide by zero\");\n    }\n    a / b\n}"
21:24:46 [INFO] Function belongs to crate: toy_rust
21:24:46 [INFO] Macro calls found: 1
21:24:46 [INFO] macro call resolved: "panic!(\"Cannot divide by zero\")"
21:24:46 [INFO] macro crate name: "std"
21:24:46 [INFO] 
 ----------- done with file ----------- 

21:24:52 [INFO] number of resolved external functions / Number of external functions: 17311 / 67184
21:24:52 [INFO] number of resolved internal functions / Number of internal functions: 6 / 6
21:24:52 [INFO] name: "0.1.0"
21:24:52 [INFO] name: "cfg_if"
21:24:52 [INFO] name: "getrandom"
21:24:52 [INFO] name: "libc"
21:24:52 [INFO] name: "ppv_lite86"
21:24:52 [INFO] name: "rand"
21:24:52 [INFO] name: "rand_chacha"
21:24:52 [INFO] name: "rand_core"
21:24:52 [INFO] name: "zerocopy"
21:24:52 [INFO] name: "0.1.0"
21:24:52 [INFO] name: "cfg_if"
21:24:52 [INFO] name: "getrandom"
21:24:52 [INFO] name: "libc"
21:24:52 [INFO] name: "ppv_lite86"
21:24:52 [INFO] name: "rand"
21:24:52 [INFO] name: "rand_chacha"
21:24:52 [INFO] name: "rand_core"
21:24:52 [INFO] name: "zerocopy"
21:24:52 [INFO] SBOM dep num 8
21:24:52 [INFO] crate_link, rand0.8.5: None :  "https://rust-random.github.io/book"
21:24:52 [INFO] crate_link, rand0.8.5: None :  "https://rust-random.github.io/book"
